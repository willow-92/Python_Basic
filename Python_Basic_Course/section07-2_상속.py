# section07-2
# 파잌선 클래스 상세 이해
# 상속, 다중 상속

# 상속과 다중상속
# 지난시간에 어떤 클래스 변수는 공통으로 모두 접근이 가능해서 공유한다고 했고. 각각의 클래스를 바탕으로 생성된 인스턴스는
# 자기 자신의 네임 스페이스를 가지고 자기 자신의 속성, 메소드를 관리한다고 했습니다.
# 그래서 클래스도 네임 스페이스가 있따. dir이라는 함수로 출력을 해볼수가 있었다. 
# 클래스 상속과 파이썬의 특징인 다중상속
# 상속 부모에게 물려받는 것. 부모가 가지고 있는 모든 속성과 메소드를 자식에서 사용할 수가 있다. 
# 상속은 객체지향 프로그램에서 주는 이점이 너무 많기 떄문에 모든 언어에서 거의 다 제공하고 있따. 
# 물론 객체지향에서. 
# 그 중에서 파이썬은 다중상속을 허용하고 있다. 자바는 다중상속이 아닌 인터페이스를 지원한다. 
# 일단 만들면서 실습을 한다. 

# 상속 기본
# 부모 클래스 = 슈퍼 클래스
# 자식 = 서브 클래스
# 부모가 가지고 있는 재산을 물려 받았기 때문에 모든 속성 메소드를 사용 가능하다.

# 상속을 왜 사용할까? 
# 많은 이유들이 구글에서 상속의 필요성, 상속이 필요한 이유, 이런 것으로 검색해보면 많이 나옴
# 기초에서 알아둬야 할 것은, 상속을 통해서 코딩을 하면, 코드를 재사용 할 수 있고.
# 중복되는 코드를 최소화 할 수 있다는 것.
# 그래서 코드의 생산성과 유지보수, 가독성과 관련이 있다.
# 복잡한 코드를 단순화 하기 위한 객체지향 프로그래밍에서 상속, 클래스 이런게 나오기 시작했다.
# 라면이 있다고 했을 때, 이 라면은 속성이 뭐가 있을까? 
# 라면 종류가 여러가지인데, 종류가 될 수도 있을것이고. 제조사도 있을 수 있고. 맛, 면 종류, 라면 이름 이런 것들이 공통적인 속성으로 뽑을 수 있다.
# 이런 것들을 공통적으로 가지고 있는 것을 부모 클래스에서 생성하고
# 자식은 라면이라는 클래스를 상속을 받아서 공통으로 쓸 수 있는 것들은 물려받아서 속성과 메소드로 사용하고
# 나머지 것들은 각자 자식 클래스에서 구현해서 사용한다면 각각 하나하나에 라면 클래스를 생성하는 것 보다, (속성이 중복됨) 
# 하나의 클래스에서 공통 속성을 제거하고 상속받는 서브 클래스에서는 코드를 재사용하니까 코드 양이 줄어든다.
# 
# 예제 1
class Car:
    """Parent Class"""
    def __init__(self, tp, color):
        self.type = tp
        self.color = color

    def show(self):
        return 'Car Class "Show Method!"'

class BmwCar(Car):
    """Sub Class"""
    def __init__(self, car_name, tp, color):
        super().__init__(tp, color)
        self.car_name = car_name
    
    def show_model(self) -> None:
        return "Your Car Name : %s" % self.car_name


class BenzCar(Car):
    """Sub Class"""
    def __init__(self, car_name, tp, color):
        super().__init__(tp, color)
        self.car_name = car_name
    
    def show_model(self) -> None:
        return "Your Car Name : %s" % self.car_name

    def show(self):
        print(super().show()) #자식이 오버라이딩되서 호출 되지만 부모 것도 호출하고 싶을 때
        return 'Car Info : %s %s %s' % (self.car_name, self.type, self.color)
        

# 일반 사용
model1 = BmwCar('520d', 'sedan', 'red')

print(model1.color) # Super
print(model1.type) # Super
print(model1.car_name) #Sub
print(model1.show())

# 여러 클래스가 한 메소드를 공유한다면 코드의 중복을 피하고.
# car class를 상속받아서 사용할 수 있다.

print(model1.show_model()) #sub

# 부모의 있는 모든 속성과 메소드에 접근 가능하고. 자식도 자식만의 데이터를 네임스페이스에서 보관할 수 있따. 
print(model1.__dict__)
# 당연히 car name은 자식에서 생성할 때 초기화 한 것이고, 부모에서 초기화 한 것도 확인할 수가 있는 것. 

# Method Overriding(오버라이딩)
# 오버라이딩이라는 뜻은 올라타다 라는 뜻.
# 무슨 의미인지 실습으로 확인

model2 = BenzCar("220d", 'sub', "black")
 # 여기서 BMW 클래스와 Benz 클래스가 똑같다. 
 # Benz에 메소드를 선언할 것인데, show()라는 메소드.

 # 근데 얘는 부모에게도 있는 메소드
 # 부모에게도 있는 메소드를 자식에게도 똑같이 선언을 한 것.

print(model2.show())
# 아까 모델1에서 호출할 때는 BMW subclass에서는 show라는 메소드가 없기 때문에 부모에 있는게 호출이 되었다. 
# 부모에게 있는 메소드를 자식에게 똑같은 이름으로 구현 했을 때는 어떤 일이 일어났는가? 
# Car Info : 220d sub black
# 지금 현재 메소드는 서브 클래스에 있는 메소드가 실행되었음. 이게 오버라이딩
# 부모에 있는 것을 모두 사용하는게 아니라, 입맛에 맛게 자식에서 상속 받을 것은 받고.
# 기능을 개선하거나 추가하거나, 이름을 똑같이 하고 내용을 다르게 할 수 있음. 
# 내 목적에 맞게 메소드를 재구현하는 것. 그때 자식에 있는 게 호출이 되는 것
# 부모에 있던 메소드에 올라타서 자식 메소드를 구현해서 자식 것을 실행하는 것. 즉 코드를 재활용 할 수 있음
# 부모에서 반드시 상속을 받아야 해 라고 했지만, 맘에 안들면 새롭게 이름만 똑같이 하고 코드의 구현은 다르게 할 수 있음.
# 이런 것들은 자바에도 있고. 오버로딩이라는 개념도 있기는 한데, 파이썬에서는 오버라이딩
# 그래야 잘 만들어진 다른 개발자들의 소스나 오픈소스, 기존에 패키지 안에 있는 모듈 소스를 분석할 수가 있다. 

# Parent Method Call
# 부모의 메소드를 다이렉트로 콜 하는 방법

model3 = BenzCar("350s", "sedan", "silver")
print(model3.show())
# Car Info : 350s sedan silver
# 출력하면 오버라이딩된 메소드가 출력된다.
# 근데 부모 까지 호출하고 싶다?
# super 메소드로 호출하면 부모에 접근할 수 있다고 했다.
# super 라는 예약어를 통해서 부모라든지, 생성자, 이런 속성에 접근이 가능하다는 뜻

# 상속관계의 depth가 깊을 때, A가 B를 상속받고, B가 C를 상속받고 이렇게 깊을 때 이걸 표현하는 메소드가 파이썬에 있음
# 상속 = Inheritance Info
# 보고 싶은 클래스를 쓰고 mro 메소드를 호출
print(BmwCar.mro())
# [<class '__main__.BmwCar'>, <class '__main__.Car'>, <class 'object'>]
# 상속관계가 나타남
# BMW 클래스는 car 클래스를 상속 받았고, car 클래스는 파이썬의 모든 데이터 타입도 클래스로 표현이 되는데, 모든 클래스는 오브젝트 클래스를 상속을 받는다.
# 항상 파이썬에서 다루는 자료형은 클래스로 표현할 수 있고. 오브젝트 클래스가 모든 클래스의 부모라고 생각하면 됨
# BMW는 car class를 상속 받았다고 알 수가 있다. 

# car class가 다른 것을 상속 받았으면 계속 뭔가 나오다가 object클래스가 나오게 된다.
# Benz로 바꾸면 똑같다. 

print(BenzCar.mro())
# [<class '__main__.BenzCar'>, <class '__main__.Car'>, <class 'object'>]
# mro는 상속 정보를 리스트 형태로 반환해주는 메소드. 

# 예제 2
# 다중 상속

class X():
    pass

class Y():
    pass

class Z():
    pass

# 클래스 A는 x와 y를 상속받겠다.
# A는 X와 Y에 클래스에 있는 어떤 속성과 메소드에 상속받아서 재사용 또는 오버라이딩이 가능하다. 
class A(X, Y):
    pass

class B(Y, Z):
    pass

class M(B, A, Z):
    pass

print(M.mro())
# [<class '__main__.M'>, <class '__main__.B'>, <class '__main__.A'>, <class '__main__.X'>, <class '__main__.Y'>, <class '__main__.Z'>, <class 'object'>]
# M 클래스는 B를 상속 받고, A를 받았고, 그 다음에 따라 올라간다. B는 Y, Z를 받았기 때문에 X, Y. Z는 원래 있던 것을 상속 받은 것. 
# 즉 모든 클래스를 이 안에서 사용할 수 있는 것.
# 클래스 안에 있는 X, Y, Z, A, B에 있는 속성과 메소드 값을 M에서 모두 물려받았기 때문에 다중상속이 된다고 증명을 할 수 있는 것. 
# 너무 복잡한 다중상속은 코드를 해석하기가 어려울 수 있음. 
# 보통은 한 2개 정도를 상속 받아서 복잡한 것을 구현할 때는. A는 전자계통, B는 화학계통. 2 개통의 클래스를 상속받아서 새로운 것을 조합해서 오버라이딩 하거나 기능을 구현할 수 있는데,
# 지금 같은 예제로 너무 클래스가 depth가 깊으면 따라 가면서 다 찾아야 한다. 출력을 해도 복잡하다. 
# 그렇기 때문에 상속을 너무 깊게는 하지 않는 것으로. 

print(A.mro())
# A는 반면에 X와 Y를 받았다. 

# 다중 상속을 통해서 일반적인 클래스. car 클래스를 하나만 받았을 때 보다 유기적이고. 맞물려서 돌아가는 클래스의 공통 기능을 하는 성격을 가진 클래스를 묶어서 코딩을 해놓고
# 하위로 다중 상속을 받아서 어플리케이션을 구조적으로 완성시켜갈 수 있음.
# 파이썬의 유연함

# 3개를 상속 받고, 5개 받고 , 10개 받고 depth가 깊어질수록 코드의 복잡도가 상승할 수 있다. 
# 언젠가 실력이 붙어서 이런 상속들을 자유자제로 사용해서 코딩을 할 수 있는데, 그때 복잡도가 높지 않게 사용해야 한다. 

