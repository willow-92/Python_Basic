# section 07
# 파이썬 클래스

# 클래스를 왜 배울까?
# 객체 지향 프로그램 - 자바 , C++, 고랭, 자바스크립트, 뷰
# 이런 언어 프로그래밍도 클래스 형태의 패턴을 제공한다.
# 클래스의 사용 이유는 어떤 프로그램이 커지면, 처리해야 할 메소드라던지
# 예를 들어 쥐마켓을 생각해보자. 그런 방대한 어플리케이션이 운영되기 위해서는 클래스 방식의 코딩을 해서 구조화를 시키고. 
# 서로간의 결합을 느슨하게 해서. 맨날 사이트가 버그가 발견되고 기능이 추가되고. 기존에 되었던 성능을 개선시키고. 
# 이런 작업이 매일 일어나고 있다. 이떄 일괄적으로 기계식 프로래밍을 해 놓으면, 많은 변수를 선언하고. 정말 유지보수나 생산성이 떨어진다. 
# 이런 클래스 프로그래밍을 하므로써 데이터를 효율적으로 관리하고. 같은 코드의 반복을 없애고.
# 상속을 이용해서 재활용하는. 부모에서 가지고 있는 것을 자식에서 재활용하는.
# 결국 그러므로써 객체지향 프로그래밍이 나온 것.
# 이런 복잡한 처리 과정 및 데이터에서 조금 더 편하게 탈피하고자 객체지향 프로그램이 대두되었다고 볼 수 있다. 
# 결론은, 클래스 코딩을 해야 한다. 
# 파이썬 실력이 붙으면, 많은 소스들을, 다른 개발자나 잘 만들어진 패키지 소스를 접하게 될 텐데, 그때 보면 클래스 코딩을 해 놓았고
# 명확하게 클래스 단위로 기능분류를 해 놓았다. 

# 파이썬 클래스 상세 이해
# Self, 클래스, 인스턴스 변수

# 클래스를 잘 활용하려면, 파이썬에서 클래스 선언 방법을 알아야 함
# 선언
# class 클래스명: 
#     함수
#     함수
#     함수

# 기본적인 선언은 클래스명과 이 클래스 안에서 사용할, 이 클래스와 관련이 있는 것들을 만들어서 코딩을 하게 된다.
# 예를 들어서 학생 클래스다, 그러면 성적 계산해주는 함수, 수학 성적을 계산해주는 함수, 총점 계산 함수를 학생 클래스에 모아 놓으면 관리가 편하다. 

# 예제 1

# 클래스 네이밍의 원칙. 첫 글자를 대문자로 하는 것을 원칙으로 한다. 
# 단어와 단어가 연결 될 경우 해당 단어의 첫 글자는 대문자로. 모든 언어에서 클래스를 선언하는 변수
# class UserInfo:
#     pass

# pass 라는 예약어를 해 놓으면 에러가 나지 않는다.
# 패스가 없으면 에러가 나온다. 
# 유저 인포가 사람을 저장한다고 할 때, 사람에는 속성이 여러가지가 있따.
# 클래스는 2가지 형태로 구성됨. 속성과 메소드.

# 속성에는 뭐가 있을까?
# 이름, 나이, 성별, 키, 몸무게 이런게 다 속성이 될 수 있따.
# 메소드는? 움직임이 있는 것이라고 볼 수 있는데, 걷다, 뛰다, 누워있따.
# 이 유저가 사람의 클래스라면, 메소드는 어떤 움직임이 있는 것들을 구현할 수가 있다.
# 만약 필기도구라는 클래스를 선언했다면, 제조사, 컬러 등이 될 수 있을 것이고. 
# 메소드는 누르다, 또 다시 누르면 볼펜심이 들어가고 이런 것들.
# 펜을 달다, 교체하고. 이런 것들을 메소드로 만들 수가 있다. 속성과 메소드로 클래스가 구성된다고 이해하면 된다. 



# class UserInfo:
#     def __init__(self):
#         print("초기화")

# 클래스 안에서 구현해야 할 메소드. 언더바를 2개 하면, 매직매소드라고 하는게 나오는데
# 여기 init이라고 있다. 이게 바로 클래스를 최초 초기화 할 때 호출되는 함수이고 구현을 해야 한다. 
# 클래스 선언은 붕어빵 틀을 만든 것이고. 
# 여기에 이제 붕어빵 반죽을 넣어서 찍어 내야 메모리에 올려서 사용하는 것.

# user1 = UserInfo()

# 실행을 하면, 바로 자동으로 초기화가 이 클래스가 메모리에 User1에 할당되는 순간에 호출이 되서, 초기화라는게 출력이 된 것을 확인할수가 있다.
# 속성을 넣어보자.
# 클래스는 속성과 메소드로 구현되어 있다.
# 유저의 기본적인 속성은 뭐가 있을까? name
#
# class UserInfo:
#     # 속성, 메소드
#     def __init__(self, name):
#         self.name = name
#     def user_info_p(self):
#         print("Name : ", self.name)

# user1 = UserInfo()

# 이러면 에러. 유저 인포가 붕어빵 기계에 찍혀질 때, 인스턴스화 될 때 네임을 받아서 내 자신만의 영역에 저장을 하는데, 네임을 넘기지 않아서 에러가 나옴.

# class UserInfo:
#     # 속성, 메소드
#     def __init__(self, name):
#         self.name = name
#     def user_info_p(self):
#         print("Name : ", self.name)

# user1 = UserInfo("kim")

# # 이러면 에러가 안나온다.

# user1.user_info_p()
# # 이때 유저 1에 해당하는 정보를 출력해 주는 것을 확인할 수 있다. 







# class UserInfo:
#     # 속성, 메소드
#     def __init__(self, name):
#         self.name = name
#     def user_info_p(self):
#         print("Name : ", self.name)

# # user1 = UserInfo("kim")
# # 인스턴스화 한다 그럼 할당한다.
# # 클래스 형태로 구성된 유저 정보들을 쉽게 관리할 수 있따. 

# user1 = UserInfo("kim")
# user1.user_info_p()
# user2 = UserInfo("Park")
# user2.user_info_p()

# # 인스턴스가 뭐냐? 만약 유저 1과 2는 같지 않다.
# # 위에 네임은 김이고, 유저 2의 변수의 값은 박이다.
# # 이름 뿐만 아니라 키 성별 성적 주소 이런 모든 속성값이 다를텐데, 이 유저 1의 네임 스페이스 안에는 찍어보면 유저 1에 네임을 출력해보자.
# # 김이 있다. 그리고 유저 2에는 당연히 박이 들어있다. 

# # 인스턴스가 가지고 있는 자기 자신의 저장 공간. 네임 스페이스 안에는 전혀 다른 값이 들어가게 된다. 
# # 그래서 유저 1과 유저 2는 다르다.
# # 증명을 해보면, 

# # id는 메모리의 주소값을 찍어줌. 
# print(id(user1))
# print(id(user2))

# # 서로 다른 값이 나옴
# # 클래스를 생성해서 클래스를 이용해서 클래스를 생성해서 인스턴스화 시켜서 사용하고 있다.
# # 그 인스턴스화 된 변수들은 서로 독립적인 네임 스페이스라는 창고를 이용해서 그 안에 네임이나 성별 등을 저장하고 있다는 것을 확인할 수 있다.
# # 네임 스페이스는 print(user1.__dict__)

# print(user1.__dict__)
# print(user2.__dict__)

# 유저 1 인스턴스의 네임스페이스에는 킴이 있고. 키와 벨류 형태로. 
# 유저 2에서는 다르게 구성되어 있는 것을 확인할 수가 있다.

# 클래스와 인스턴스를 구분하는 것이 중요
# 클래스 형태로 코딩을 한 뒤 변수에 할당해서 인스턴스화 시켜서,
# 클래스를 객체라고 하는데, 이걸 인스턴스화 시켜서 메모리에 올려서, 페이 로드 해서 사용을 한다. 
# 네임스페이스: 각각의 객체를 인스턴스화 할 때 저장된 공간. 자기 이름, 자기 나이, 자기 주소 이런 것들을 가지고 있는 독립적인 공간
# 변수에는 2 종류가 있는데, 클래스 변수는 직접 사용 가능하고. 객체 보다 먼저 생성된다는 특징지 있음
# 인스턴스 변수는 객체마다 별도로 존재함. 인스턴스 생성 후 사용한다.
# 인스턴스화 된 메소드를 호출하니까, 독립적인 공간에 있던 이름을 출력한 것
# 별도로 존재하고. 아이디값을 출력해보디 둘 다 다른 값을 가지고 있다는 것을 증명했음
# 예제 2번에서 self가 도대체 무엇인지 하는 의문이 있을것이다.

# 예제 2
# self의 이해
# class SelfTest() 와 같이 괄호가 있어도 됨
# class SelfTest:
#     def function1():
#         print('function1 called!')
#     def function2(self):
#         print(id(self))
#         print('function2 called!')

# self_test = SelfTest()
# # self_test.function1()
# # self_test.function1()은 self_test라는 클래스를 바탕으로 찍어낸 인스턴스임. 인스턴스가 이걸 호출 해오려고 하니까 function1은 셀프 인자가 없기 때문에 누구의 function1함수인지 모르는 것. 
# # 클래스 메소드인 것. 이럴 때는 아래와 같이 클래스에서 호출을 해야 함

# SelfTest.function1()
# self_test.function2()

# # function1은 클래스 메소드이고 function2는 인스턴스 메소드임
# # 인스턴스를 생성해야 해당 self안에 네임스페이스에 이런 셀프, 각각의 네임스페이스에 이름을 집어 넣어 놓았기 때문에,
# # 2버 function은 호출이 되는 것이고, 1번은 이 메소드를 인스턴스에서는 호출할 수가 없는 것. 셀프 인자가 없기 때문에. 
# # 이걸 증명하려면 Id 값을 찍어보면 됨

# print(id(self_test))
 
# # 아이디가 동일하게 나옴
# # 그 뜻은 self test가 자동으로 넘어갔다고 볼 수 있음
# # 그렇기 때문에 자기 고유의 인스턴스를 가질 수가 있는 것. 

# # SelfTest.function2()
# # 위와 같이 호출해도 에러가 발생된다. 왜냐하면 클래스 정의 할 때 셀프 인자를 받으라고 되어 있는데, 방금 호출할 때는 인자가 없으니까. 
# # 그렇 어떻게 해야 하냐? self_test를 인자로 넣어주면 된다.
# SelfTest.function2(self_test)

# 3개가 다 같은 id값
# 3개 다 같은 id값. 
# 그렇기 때문에 셀프가 들어간 함수는 인스턴스 함수라고 알아두시고. 셀프가 없으면 클래스에서 직접 호출할 수 있는 공통함수로서 사용할 수 있는 것'
# 여러 인스턴스가 공유하는 함수라고 볼 수 있고. 호출할 때는 클래스 이름으로 호출을 해야 한다는 것. 
# 나머지 셀프가 있는 것은 인스턴스를 생성해서 호출하거나 클래스를 생성해서, 클래스를 바로 즉시 호출해서 인자로 넣어줘야 한다는 것을 확인할 수 있음
# 네임 스페이스를 가지기 떄문에.

# 클래스는 직접사용이 가능하다고 했는데, 인스턴스보다 먼저 생성되기 때문에 여기서 호출을 하면 셀프 테스트의 펑션 1을 호출하니까 호출할 수가 없었던 것
# 인스턴스를 생성하는 메소드는 셀프 인자가 자동으로 넘어간다고 이해하면 된다. 
# 셀프 인자가 없는 것들은 클래스에서 직접 호출한다고 정리하고 넘어가면 된다. 

# 예제 3번
# 클래스 변수와 인스턴스 변수
# 클래스 변수는 Self가 없음

class WareHouse:
    # 클래스 변수
    stock_num = 0
    def __init__(self, name):
        self.name = name
        WareHouse.stock_num += 1
    def __del__(self):
        WareHouse.stock_num -= 1

user1 = WareHouse('kim')
user2 = WareHouse('Park')
user3 = WareHouse('Lee')

# 네임스페이스 찍기
print(user1.__dict__)
print(user2.__dict__)
print(user3.__dict__)

# 네임스페이스를 다 출력해보면{'name': 'kim'}
# {'name': 'kim'}
# {'name': 'Park'}
# {'name': 'Lee'}
# 각 네임스페이스 구간 안에, 김, 박, 이가 사용하는데, 중요한 것은 클래스 안에서 선언한 숫자는 나오지 않는다. 
# 왜? 셀프가 아니니까.
# 그러면 WareHouse에 dict을 출력해보면 나온다. 
print(WareHouse.__dict__)
# {'__module__': '__main__', 'stock_num': 3, '__init__': <function WareHouse.__init__ at 0x000002A6D47CAD40>, '__del__': <function WareHouse.__del__ at 0x000002A6D47CA830>, '__dict__': <attribute '__dict__' of 'WareHouse' objects>, '__weakref__': <attribute '__weakref__' of 'WareHouse' objects>, '__doc__': None}
# 여기에 stock_num이 3이 되어 있다. 중요한 개념
# 클래스 변수는 모두가 공유하기 때문에 인스턴스가 하나 생성될 때 마다 아래 코드 구간이 호출이 되면서 

    # def __init__(self, name):
    #     self.name = name
    #     WareHouse.stock_num += 1 

# 총 3명이 이 창고를 사용하고 있게 되는 것. 

print(user1.name)
print(user2.name)
print(user3.name)

# 위와 같이 하면 아래와 같이 유저의 이름을 다 출력할 수 있게 됨
# kim
# Park
# Lee

print(WareHouse.__dict__) #클래스 네임 스페이스. 클래스 변수는 (공유)

# 아래는 인스턴스 변수들. 각각 자기 것은 가지고 있음. 

print(user1.__dict__)
print(user2.__dict__)
print(user3.__dict__)

# 공유하기 때문에 print의 유저 1의 stock_num 으로 접근이 가능할까?
# 이 안에 stcok_num이 없는데, class에 들어있는데, 될까?
print(user1.stock_num) 
# 출력이 된다. 자기 네임 스페이스에 없으면 클래스에 가서 찾는다.

# 자기 네임 스페이스에 없으면 클래스 네임스페이스에 가서 변수를 찾고. 
# 거기에도 없으면 에러가 발생한다. 

print(user1.stock_num) 
print(user2.stock_num) 
print(user3.stock_num) 
del user1

print(user2.stock_num) 
# 나중에 배우겠지만 del이라는 함수로 인스턴스를 삭제할 수 있음. 
# 이때 1번을 지웠기 때문에 2번 3번만 출력해보면 이때는 2가 출력이 된다. 
# 왜? 위에 짠 코드에서 지울때 출력되는 메소드가 del. 얘가 1을 공통변수에서 빼주었기 때문.

# 클래스 코딩을 할 때, 만약 직원 클래스라고 가정을 하면, 연봉 인상률이라는 변수로 가정해보자.
# 전체를 0.05로 해놓고 5% 인상이라고 하면, 모든 직원들이 연봉에서 전체 직원들의 인상률이 0.05%로 사용할 수 있음. 하나의 변수를 통해서 모든 인스턴스들이 공유하는 
# 패턴을 가지고 있는 코딩을 클래스로 구현해서 중복되는 코드도 많이 줄일수가 있음. 
# 이 개념을 반드시 알아두어야 함

# 클래스와 인스턴스 차이를 알아야 함
# 클래스는 전체에서 공유가 되고
# 인스턴스는 각자 네임 스페이스를 가지고 있다. 
# 하지만 클래스도 네임 스페이스가 있다. 
# 인스턴스 네임스페이스에서 값이 없으면, 인스턴스 네임스페이스에서 값이 없으면, 클래스 네임스페이스를 뒤져서 값을 가지고 온다.
# 그리고 직접 사용 가능하고, 객체보다 먼저 생성되고

# 인스턴스 변수도 객체마다 별도로 존재하고. 인스턴스 생성 후 사용한단.
# 네임스페이스는 클래스와 인스턴스 각각 저장된 파이썬 공간. 인트, 플롯, 모든 자료형은 네임스페이스를 가지고 있다.
# 셀프, 클래스, 인스턴스, 네임스페이스, 클래스 선언. 

# 앞으로 수업 하는 동안 저절로 이해되는 부분. 스트레스 받을 필요는 없다. 
# 구글에서 간단하게 검색 해보고 보충적으로 지식을 습득해봐라. 