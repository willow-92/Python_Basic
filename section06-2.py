# section 06 -1
# 함수식 및 람다(lambda)
# 함수는 어떤 프로그래밍 언어를 학습할 때, 이미 배운 데이터 타입과 흐름제어를 배우고 중간 과정에서 반드시 배워야 하는 섹션이다. 
# 함수는 우리가 지금까지 우리도 모르게 사용해 오고 있었다.
# 프린트 역시 함수이고, 리스트 형변환이나 리버스와 같은 것들이 이미 함수이다. 
# 함수는 입력값을 입력 받아서 출력해주는 형태가 있고
# 입력만 받고 출력은 하지 않는 형태도 있다. 

# 오늘 배울 것은 함수 정의 및 람다 표현식을 이용해서 함수를 사용
# 람다를 잘 해 놓으면 자바 8이나 람다 문법을 지원하는 프로그래밍 언어에 대응할 수 있다.

# 함수 선언과 다양한 선언, 다양한 반환값
# 아규먼트와 키워드의 매개변수를 입력받는 방법과 람다함수를 다룰 예정

# 함수를 사용하는 이유를 생각해봐야 한다.
# 함수를 사용하는 이유는 여러가지 방법이 있으나
# 반복적이고 중복되는 프로그래밍을 피할 수 있기 때문이다.
# 어떤 쇼핑몰에서 뭔가를 구매하면 결제했을 떄 문자가 오거나, 배송출발 문자가 오거나 결제 실패 문자가 오거나 
# 다양한 형태로 휴대폰으로 오는데, 이런 문자를 보내는 프로그래밍을 만든다고 생각하면, 물건을 구매했을 떄, 
# 출발했을때 등등을 함수로 만들면 어차피 기능을 구현할 목적은 문자를 보내는 것인데, 함수가 중복이 된다. 
# 문자를 보내는 내용은 함수를 하나만 구현해놓고 모든 곳에서 구현해서 함수를 사용할 수 있다는 것.
# 그럼 코드 중복도 줄어들고 코드 가독성도 높아지고, 유지보수 할 때도 기능을 추가하거나 엔진을 바꾸거나 할 때 표현을 쉽게 할 수 있다.
# 여러번 반복하는 작업을 함수를 활용해서 사용한다.

# 파이썬에서 이미 만들어진 것도 함수 형태로 제공하기 떄문에 함수에 대해 잘 알아야 한다.
# 기능변경이나 문제가 발생할 떄도 함수 수정을 통해 문제를 해결할 수 있다.
# 함수는 하나의 기능을 수행하는 것을 하나의 함수로 수행하는 것이 좋다. 
# 그래야 여러가지 함수를 만들고 이거는 이거고 여기는 여기고 이런 것 쉽게 구분할 수 있다. 

# 함수 정의 방법
# def 함수명(parameter):
#   code

# 함수 호출
# 함수명(parameter)

# 함수 선언 위치

# 예제 1
def hello(word):
    print("Hello", word)

hello("python")
hello(7777)

# 왜 선언 위치가 중요할까?
# 만약 함수보다 선언위치가 더 위에 있다면 함수가 정의되어 있지 않기 때문에 에러가 발생한다.

# 그러면 리턴이 있다면?

# 예제 2
def hello_return(word):
    val = "Hello " + str(word)
    return val
# 리턴은 이 함수를 호출한 다음에 값을 반환한다는 의미

str = hello_return("Python!!!!!")
print(str)

# 즉 str에는 헬로 파이썬 문자열이 완성이 되어서 이게 반환이 되어서 str에 포함되어 있는 것. 그래서 그냥 출력해도 된다는 것. 
# 이건 지금 문자열을 리턴해주는 함수이고
# 위에는 리턴값이 없는 함수이다. 
# 리턴이라는 예약어를 통해서 함수를 호출한 곳으로 함수 안에서 일련의 처리 작업을 한 다음에 그 값을 리턴해서 출력할 수 있다는 것. 

# 예제3 (다중리턴)
# 여러개의 값을 짜임새 있게 프로그래밍 할 수 있게 됨
# 예제 2에서는 리턴 되는게 하나
# 자바나 기타 언어도 리턴은 1개가 원칙인 언어가 많은데, 파이썬은 다름

def func_mul(x):
    y1 = x * 100
    y2 = x * 200
    y3 = x * 300
    # x에 대한 매개변수를 가지고 3개의 값을 만든 것
    return y1, y2, y3

# 그러면 받는 쪽에서는 어떻게 사용해야 할까?
# 3개의 값이 넘어오기 때문에 아래처럼 3개를 받아야 함
val1, val2, val3 = func_mul(100)
print(val1, val2, val3)

# 다양한 계산을 해서 한 번에 리턴을 해주는 라이브러리도 많다.
# 다중리턴이 가능하기 때문에 숙지를 해야 한다. 
# 조금만 생각해보면 넘길 때 자료형이 뭔지, 데이터타입이 뭔지 궁금할 수 있음. 
# 예제 3의 경우 자동으로 int 형태의 자료가 받아지지만, 리스트로 받고 싶다면?

# 예제 4 (데이터 타입 반환)
def func_mul2(x):
    y1 = x * 100
    y2 = x * 200
    y3 = x * 300
    return [y1, y2, y3]
#   튜플로 보내고 싶으면 (y1, y2, y3)

lt = func_mul2(100)
print(lt, type(lt))

# 리턴 값에 대한 데이터 형태를 원하는 값으로 반환을 받아서 사용하는게 코드 량을 줄일 수 있게 된다.
# 코드량만 줄이려고 하는게 좋은 것은 아니지만, 어느정도 리스트를 생성해서 만드는 함수다 라고 주석을 달아놓고 함수를 만들면 유용할 수 있음. 

# 예제 4
# 많이들 질문하는 부분.
# 유연하게 함수를 잘 활용할 수 있는 부분
# 외국 소스를 보면 아래 같은 부분들이 많이 있음
# *args, *kwargs

def args_func(*args):
    for t in args:
        print(t)

args_func('kim')
# 출력을 하면 튜플 형태로 kim이 하나가 넘어왔다.
args_func('kim', 'park')
args_func('kim', 'park', 'Lee')

# 가변. 매개변수가 몇 개가 넘어갈 지 모를 때, 또는 매개변수가 넘어오는 것에 따라서 함수의 작동을 달리할 때.
# 멀티플한. 다양한 매개변수 형태를 받아서 함수의 흐름이 바뀌는 기능을 할 때, 이런 것들을 많이 이용한다.
# 하나를 넣어도, 두개를 넣어도 다 튜플 형태로 작동을 한다. 
# 타입을 찍어보면 튜플 형태로 넘어온다. 
# 튜플로 넘어온다는 것은, 이터레이트가 가능하다.

def args_func(*args):
    for i, v in enumerate(args):
        print(i, v)
args_func('kim', 'park', 'Lee')
# 튜플은 인덱스가 없는데, 이뉴머레이트를 사용하면 인덱스를 보여줄 수 있음. 

# range 함수를 넣으면 인덱스도 만들어지고 숫자도 만들어져서 출력이 가능한다. 
def args_func(*args):
    for i, v in enumerate(range(10)):
        print(i, v)
args_func('kim', 'park', 'Lee')


# kwargs (키워드의 줄임말)
# 키워드 파라미터는 별표가 하나일 때는 튜플로 받는데, 별표가 2개 일때는 딕셔너리로 받는다.
def kwargs_func(**kwargs):
    print(kwargs)

# 딕셔너리로 받기 때문에 이 함수는 딕셔너리 형태로 넘겨줄 수 있다. 
kwargs_func(name1 = 'kim', name2 = 'park', name3 = 'lee')
# 가변. 개수도 늘릴 수 있고, 딕셔너리도 보낼 수 있다.
# 출력하면 딕셔너리가 나온다.

# 딕셔너리가 인자로 넘어간다는 것은?
def kwargs_func(**kwargs):
    for k, v in kwargs.items():
        print(k, v)
        
kwargs_func(name1 = 'kim', name2 = 'park', name3 = 'lee')
# 별표가 하나인 것은 튜플로. 가변인자. 여러개를 유연하게 넘길 수 있다는 것이고.
# 별표가 2개인 것은 딕셔너리로 넘길 수 있다는 것. 

# 응용. 전체 혼합
# 아래와 같이 구현하면, arg1, arg2는 필수적으로 함수를 호출할 때 써야 하는 것이고, *args는 가변인자이고, 튜플 형태로 입력을 받는 것, **kwargs는 딕셔너리 형태로 인자를 받아서 처리를 해서 구현하겠다는 의미
# 이렇게 함수를 선언하면, 다양한 데이터를 가변적으로 받아서, 함수가 추가로 있을 경우, 없을 경우를 생각해 함수를 보다 고도화 되게 안에서 더욱 복잡한 하나의 단순한 기능을 할 수도 있고, 복잡한 기능을 할 수 있겠지만,
# 기능을 함축해서 코딩을 할 수 있게 된다.

def example_mul(arg1, arg2, *args, **kwarsgs):
    print(arg1, arg2, args, kwarsgs)

example_mul(10, 20)
# 이 상태에서 출력을 하면? 
# 그래도 출력이 됨. *args는 가변인자이기 때문에 있어도 그만, 없어도 그만. 그래서 빈 튜플만 출력이 됨. 그리고 빈 딕셔너리. 
# 구지 활용을 안 하고 리턴할 때 arg1, 2를 계산하는 경우를 리턴하면 됨
# 리턴을 여러개 할 수도 있음

example_mul(10, 20, 'park', 'kim', age1 = 24, age=35)
# 이렇게 넣으면 튜플 형태의 인자도 출력을 하고, 딕셔너리 형태도 함수의 인자로 넘어간다. 여러개의 인자를 활용해서 중요한 역할을 하는 효율적인 코드를 통해서 함수의 기능을 구현할 수가 있다.
# 꼭 알아두어야 한다. 


# 중첩함수(클로저)
# 고급 프로그래머가 되기 위해서는 클로저도 학습을 해야 한다. 언어를 가리지 않는다. 모든 언어에 있다.
# 자바스크립트 뿐만 아니라 어디서든 있다. 

# 말 그래도 함수 안에 함수가 있는 것. 

# 첫 번째 인자에서 받은 파라미터를 아래 함수로 넘긴 형태
def nested_func(num):
    def func_in_func(num):
        print('>>>>' , num)
    print("in func")
    func_in_func(num + 10000)
nested_func(10000)

# 기초과정에서 하기에는 좀 어려운 내용이기 때문에, 변수의 스코프 이런건 안 하지만
# 흐름만 본다면, 처음 num에 10000이 들어가서 아래 있는 func_in_func의num으로 넘겨졌음. 다만 함수가 선언만 되어 있고 출력, 실행은 아직 안 되었음. 
# 실행은 func_in_func(num +10000) 이 부분에서 함
# in_func라는 것을 먼저 출력을 해주고, 함수를 그때 가서 출력을 실행하고 있음. 그때 인자로 넘어온 num을 1만을 넘겨서 1만 + 1만 = 2만이 func_in_func로 넘어가고, 최종적으로 실행되는 것이 print문에서 출력되는 2만.
# 2만이 함수 안에 있는 함수 형태로 출력을 할 수 있고. 이걸 클로저 형태로 사용하면 변수의 선언을 줄일 수 있고, 메모리 관리를 효율적으로 할 수 있고. 
# 나중에 파이썬에 고급 과정에서 찾아보면, 데코레이터라고 있다. 

# 기초과정에서 다를 것은 아니지만, 이런게 있구나 하고 꼭 검색해보라. 
# 파이썬 데코레이터 클로저 라고 하면, 어떤 내용들이 많이 있음.
# 파이썬 클로저라고 해서, 생긴게 중첩함수랑 비슷하게 생겼다. 
# 궁극적으로 데코레이터까지 하기 위해서는 중첩함수를 다뤄야 한다. 
# 관심이 있거나 아예 초보가 아니면 클로저를 공부해보길
# 기초 문법을 듣고 실력이 붙으면 클로저와 데코레이터를 검색해서 학습을 심화있게 하는 것을 추천함