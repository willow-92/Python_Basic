# # section04-3
# # 파이썬 데이터 타입 (자료형)
# # 딕셔너리(Dictionary), 셋

# 딕셔너리 제이슨과 비슷

# 딕셔너리의 특징
# 순서 x, 중복 x, 수정 o , 삭제 o

# 딕셔너리는 Key와 Value로 이루어져 있음.
# 데이터의 송수신에 이용하는 Json 형식이 있는데, Json과 형식이 유사함.
# Json 형식으로 하는 데이터 베이스도 많음. 몽고DB 등.
# 이런 데이터 형식은 매우 중요함.

# 선언
# 이름은 누구, 점수는 몇 점, 전화번호는 뭐,
# 키는 가져오고자 하는 정보. 그 안에 값이 있는 것.
# 키를 가지고 값을 조회하는 개념
# 똑 같은 열쇠가 2개가 될 수 없듯, 키는 하나.
# 순서와 상관 없이 출력이 이루어짐

# 선언
a = {'name': 'kim', 'phone': '010-7777-7777', 'birth': 920202, }
# 키 값을 기준으로 값을 가져오기 때문에 순서가 상관이 없음.
# 키가 중복을 허용하지 않음. name이 하나 더 들어가면 안되기 때문에 중복 x.

b = {0: 'hello python,', 1: 'hello coding'}
# 숫자도 키값이 될 수 있지만 잘 사용하지 않음.

c = {'arr': [1, 2, 3, 4, 5]}
# 어떠한 데이터의 값도 파이썬 딕셔너리 값에 들어올 수 있음. 리스트 형태, 튜플 형태, 인트, 스트링, 플롯, 불린, 컴플렉스 등 전부 다 값 부분에 넣을 수 있음.
# 매우 유연하게 사용할 수 있는 데이터 자료 구조.

print(type(a))

# 출력
print(a['name'])
#'name1'로 조회하면 키 에러가 난다.
# 그래서 보통 안전하게 조회하려면 get 메소드를 사용한다.
print(a.get('name'))
print(a.get('address'))
# get 메소드를 사용했을 때 딕셔너리 안에 값이 없다면 None로 표기하기 때문에 에러가 발생하지 않음.
# 안전하게 조회하기 위하여 get을 사용한다.
# get 함수로 키를 찾는 방식을 추천함.

print(c['arr'])
# 위와 같이 입력하면 'arr'에 들어있는 리스트를 가지고 옴
# 당연히 슬라이싱도 적용할 수 있음.
print(c['arr'][1:3])

# 추가 - 키와 밸류를 추가
a['address'] = 'Seoul'
# 위 방식으로 키와 밸류를 추가할 수 있음.
print(a)
# 출력을 하다 보면 데이터의 순서가 바뀌어서 나올 수 있음.

a['rank'] = [1, 2, 3]
a['rank2'] = (1, 2, 3)
print(a)

#keys, values, item
# 아이템은 키와 벨류 한 쌍을 의미함. 

print(a.keys())
# 키만 리스트 형태로 가지고 옴
# 이 상태에서 인덱스에 접근하는 것은 불과함 (not support index)
# 리스트 함수를 사용하여 새로운 변수에 넣은 뒤에는 인덱싱 가능
# 형 변환이 필요함.
temp = (list(a.keys()))
print(temp[1:3])

print(a.values())
# 벨류 값만 가지고 오는 함수
# 나중에 반복문에서 for문을 통해 자동으로 반복함.
# 딕셔너리 안에 100명이 있다면 이름, 나이, 전화번호, 사는 곳, 점수 등을 쉽게 출력할 수 있음. 
# 이것이 파이썬의 꽃. 
# 반복문은 정말 간편함.
# 데이터 전처리, 후처리, 대량의 데이터를 가공할 때 파이썬의 반복문이 빛을 발함. 

temp2 = list(a.values())
print(temp)

print(a.items())
# 전체를 가져오는데, 키, 벨류를 순환하며 한 쌍으로 가지고 옴
# 이를 나중에 for 문에서 반복하면 키와 벨류를 순회하면서 출력이 가능함. 
# 역시 리스트로 형 변환이 가능함.

print(list(a.items()))
# 리스트 안에 튜플 형태로 반환을 하게 됨.

print(1 in b)
print(2 in b)

# 나중에 크롤링을 할 때 정말 많이 나옴.


# 집합(Set) (순서 x, 중복 x)
# 수치계산, 과학, 연산에 많이 활용 함. 머신러닝이나 공식을 수행할 때 오픈소스 활용에 많이 사용됨.
# 실무에서 집합을 사용할 때가 있음. 

a = set()
b = set([1, 2, 3, 4])
c = set([1, 4, 5, 6, 6])

print(type(a))
print(c)

# 6은 중복이라서 하나만 나옴
# 슬라이싱 가능. 튜플이라 리스트로 변환해서 가능
# 주로 변환해서 사용

t = tuple(b)
print(b)
l = list(b)
print(l)

print()
print()

s1 = set([1, 2, 3, 4, 5, 6])
s2 = set([4, 5, 6, 7, 8, 9])

print(s1.intersection(s2))
# 교집합 찾는 함수
# 쓰임세의 용도가 명확함

print(s1 & s2)

#합집합
print(s1 | s2)
print(s1.union(s2))

#차집합
print(s1 - s2)
print(s1.difference(s2))

# 용도에 맞게 사용하고 필요한 경우 형변환을 하여 사용하면 됨. 
# set도 추가 제거가 가능함

s3 = set([7, 8, 10, 15])
s3.add(18)
s3.add(7) # 7은 이미 있어서 중복되어 표기 안 됨. 
print(s3)

s3.remove(15)
print(s3)

print(type(s3))

# 리스트, 튜플, 딕셔너리, 셋
# 리스트는 순서, 중복, 수정, 삭제 다 허용
# 튜플은 수정, 삭제가 안됨
# 딕셔너리는 중복과 순서는 고려하지 않고 수정 삭제가 가능
# 집합은 제거도 되고 추가도 됨. 중복을 허용하지 않음. 수학시간 집합을 생각하면 됨. 



