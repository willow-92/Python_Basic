# section 07
# 파이썬 클래스

# 클래스를 왜 배울까?
# 객체 지향 프로그램 - 자바 , C++, 고랭, 자바스크립트, 뷰
# 이런 언어 프로그래밍도 클래스 형태의 패턴을 제공한다.
# 클래스의 사용 이유는 어떤 프로그램이 커지면, 처리해야 할 메소드라던지
# 예를 들어 쥐마켓을 생각해보자. 그런 방대한 어플리케이션이 운영되기 위해서는 클래스 방식의 코딩을 해서 구조화를 시키고. 
# 서로간의 결합을 느슨하게 해서. 맨날 사이트가 버그가 발견되고 기능이 추가되고. 기존에 되었던 성능을 개선시키고. 
# 이런 작업이 매일 일어나고 있다. 이떄 일괄적으로 기계식 프로래밍을 해 놓으면, 많은 변수를 선언하고. 정말 유지보수나 생산성이 떨어진다. 
# 이런 클래스 프로그래밍을 하므로써 데이터를 효율적으로 관리하고. 같은 코드의 반복을 없애고.
# 상속을 이용해서 재활용하는. 부모에서 가지고 있는 것을 자식에서 재활용하는.
# 결국 그러므로써 객체지향 프로그래밍이 나온 것.
# 이런 복잡한 처리 과정 및 데이터에서 조금 더 편하게 탈피하고자 객체지향 프로그램이 대두되었다고 볼 수 있다. 
# 결론은, 클래스 코딩을 해야 한다. 
# 파이썬 실력이 붙으면, 많은 소스들을, 다른 개발자나 잘 만들어진 패키지 소스를 접하게 될 텐데, 그때 보면 클래스 코딩을 해 놓았고
# 명확하게 클래스 단위로 기능분류를 해 놓았다. 

# 파이썬 클래스 상세 이해
# Self, 클래스, 인스턴스 변수

# 클래스를 잘 활용하려면, 파이썬에서 클래스 선언 방법을 알아야 함
# 선언
# class 클래스명: 
#     함수
#     함수
#     함수

# 기본적인 선언은 클래스명과 이 클래스 안에서 사용할, 이 클래스와 관련이 있는 것들을 만들어서 코딩을 하게 된다.
# 예를 들어서 학생 클래스다, 그러면 성적 계산해주는 함수, 수학 성적을 계산해주는 함수, 총점 계산 함수를 학생 클래스에 모아 놓으면 관리가 편하다. 

# 예제 1

# 클래스 네이밍의 원칙. 첫 글자를 대문자로 하는 것을 원칙으로 한다. 
# 단어와 단어가 연결 될 경우 해당 단어의 첫 글자는 대문자로. 모든 언어에서 클래스를 선언하는 변수
# class UserInfo:
#     pass

# pass 라는 예약어를 해 놓으면 에러가 나지 않는다.
# 패스가 없으면 에러가 나온다. 
# 유저 인포가 사람을 저장한다고 할 때, 사람에는 속성이 여러가지가 있따.
# 클래스는 2가지 형태로 구성됨. 속성과 메소드.

# 속성에는 뭐가 있을까?
# 이름, 나이, 성별, 키, 몸무게 이런게 다 속성이 될 수 있따.
# 메소드는? 움직임이 있는 것이라고 볼 수 있는데, 걷다, 뛰다, 누워있따.
# 이 유저가 사람의 클래스라면, 메소드는 어떤 움직임이 있는 것들을 구현할 수가 있다.
# 만약 필기도구라는 클래스를 선언했다면, 제조사, 컬러 등이 될 수 있을 것이고. 
# 메소드는 누르다, 또 다시 누르면 볼펜심이 들어가고 이런 것들.
# 펜을 달다, 교체하고. 이런 것들을 메소드로 만들 수가 있다. 속성과 메소드로 클래스가 구성된다고 이해하면 된다. 



# class UserInfo:
#     def __init__(self):
#         print("초기화")

# 클래스 안에서 구현해야 할 메소드. 언더바를 2개 하면, 매직매소드라고 하는게 나오는데
# 여기 init이라고 있다. 이게 바로 클래스를 최초 초기화 할 때 호출되는 함수이고 구현을 해야 한다. 
# 클래스 선언은 붕어빵 틀을 만든 것이고. 
# 여기에 이제 붕어빵 반죽을 넣어서 찍어 내야 메모리에 올려서 사용하는 것.

# user1 = UserInfo()

# 실행을 하면, 바로 자동으로 초기화가 이 클래스가 메모리에 User1에 할당되는 순간에 호출이 되서, 초기화라는게 출력이 된 것을 확인할수가 있다.
# 속성을 넣어보자.
# 클래스는 속성과 메소드로 구현되어 있다.
# 유저의 기본적인 속성은 뭐가 있을까? name
#
# class UserInfo:
#     # 속성, 메소드
#     def __init__(self, name):
#         self.name = name
#     def user_info_p(self):
#         print("Name : ", self.name)

# user1 = UserInfo()

# 이러면 에러. 유저 인포가 붕어빵 기계에 찍혀질 때, 인스턴스화 될 때 네임을 받아서 내 자신만의 영역에 저장을 하는데, 네임을 넘기지 않아서 에러가 나옴.

# class UserInfo:
#     # 속성, 메소드
#     def __init__(self, name):
#         self.name = name
#     def user_info_p(self):
#         print("Name : ", self.name)

# user1 = UserInfo("kim")

# # 이러면 에러가 안나온다.

# user1.user_info_p()
# # 이때 유저 1에 해당하는 정보를 출력해 주는 것을 확인할 수 있다. 


class UserInfo:
    # 속성, 메소드
    def __init__(self, name):
        self.name = name
    def user_info_p(self):
        print("Name : ", self.name)

# user1 = UserInfo("kim")
# 인스턴스화 한다 그럼 할당한다.
# 클래스 형태로 구성된 유저 정보들을 쉽게 관리할 수 있따. 

user1 = UserInfo("kim")
user1.user_info_p()
user2 = UserInfo("Park")
user2.user_info_p()

# 인스턴스가 뭐냐? 만약 유저 1과 2는 같지 않다.
# 위에 네임은 김이고, 유저 2의 변수의 값은 박이다.
# 이름 뿐만 아니라 키 성별 성적 주소 이런 모든 속성값이 다를텐데, 이 유저 1의 네임 스페이스 안에는 찍어보면 유저 1에 네임을 출력해보자.
# 김이 있다. 그리고 유저 2에는 당연히 박이 들어있다. 

# 인스턴스가 가지고 있는 자기 자신의 저장 공간. 네임 스페이스 안에는 전혀 다른 값이 들어가게 된다. 
# 그래서 유저 1과 유저 2는 다르다.
# 증명을 해보면, 

# id는 메모리의 주소값을 찍어줌. 
print(id(user1))
print(id(user2))

# 서로 다른 값이 나옴
# 클래스를 생성해서 클래스를 이용해서 클래스를 생성해서 인스턴스화 시켜서 사용하고 있다.
# 그 인스턴스화 된 변수들은 서로 독립적인 네임 스페이스라는 창고를 이용해서 그 안에 네임이나 성별 등을 저장하고 있다는 것을 확인할 수 있다.
# 네임 스페이스는 print(user1.__dict__)

print(user1.__dict__)
print(user2.__dict__)

# 유저 1 인스턴스의 네임스페이스에는 킴이 있고. 키와 벨류 형태로. 
# 유저 2에서는 다르게 구성되어 있는 것을 확인할 수가 있다.
