
# 부모님을 기다리던 영일이는 검정/흰 색 바둑알을 바둑판에 꽉 채워 깔아 놓고 놀다가...

# "십(+)자 뒤집기를 해볼까?"하고 생각했다.

# 십자 뒤집기는
# 그 위치에 있는 모든 가로줄 돌의 색을 반대(1->0, 0->1)로 바꾼 후, 
# 다시 그 위치에 있는 모든 세로줄 돌의 색을 반대로 바꾸는 것이다.
# 어떤 위치를 골라 집자 뒤집기를 하면, 그 위치를 제외한 가로줄과 세로줄의 색이 모두 반대로 바뀐다.

# 바둑판(19 * 19)에 흰 돌(1) 또는 검정 돌(0)이 모두 꽉 채워져 놓여있을 때,
# n개의 좌표를 입력받아 십(+)자 뒤집기한 결과를 출력하는 프로그램을 작성해보자.

# 바둑알이 깔려 있는 상황이 19 * 19 크기의 정수값으로 입력된다.
# 십자 뒤집기 횟수(n)가 입력된다.
# 십자 뒤집기 좌표가 횟수(n) 만큼 입력된다. 단, n은 10이하의 자연수이다.

# 다 못 풀었음. 다시 풀 것

# 제출용



basic = [
         [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0],
         [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], 
         [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], 
         [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], 
         [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], 
         [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], 
         [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], 
         [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], 
         [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], 
         [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
         [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], 
         [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
         [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], 
         [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], 
         [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], 
         [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], 
         [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], 
         [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], 
         [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0],
         ]

# basic = []
# for i in range(19):
#     line = map(int, input().split())
#     basic.append(list(line))
# new_basic = basic

# n = int(input())
n = 2
# # x_loc = []
# # y_loc = []
# x_loc = [10, 12]
# y_loc = [10, 12]
# for i in range(n):
#     x, y = map(int, input().split())
#     x_loc.append(x)
#     y_loc.append(y)

# 0222 다시 풀것
for i in range(n):
    x,y = input().split()
    for j in range(1,20):
        print('basic[j-1][int(y)-1] = ', basic[j-1][int(y)-1])
        if basic[j-1][int(y)-1] == 1:
            basic[j-1][int(y)-1] = 0
            print('뒤집은 후 basic[j-1][int(y)-1] = ', basic[j-1][int(y)-1])
        for i in range(19):
            print(' '.join(map(str, basic[i])))  
        else:
            basic[j-1][int(y)-1] = 1
            print('뒤집은 후 basic[j-1][int(y)-1] = ', basic[j-1][int(y)-1])
        print('basic[int(x)-1][j-1] = ', basic[int(x)-1][j-1])
        if basic[int(x)-1][j-1] == 1:
            basic[int(x)-1][j-1] = 0
            print('뒤집은 후 basic[j-1][int(x)-1] = ', basic[int(x)-1][j-1])
        else:
            basic[int(x)-1][j-1] = 1
              
for i in range(19):
    print(' '.join(map(str, basic[i])))  


# for i in range(1,20):
#     if i == x_loc[i]-1: 
#         for j in range(1,20):
#             if new_basic[i-1][j-1] == 0:
#                 new_basic[i-1][j-1] = 1
#             else:
#                 new_basic[i-1][j-1] = 0
#         if j in y_loc:
#             if new_basic[i-1][j-1] == 0:
#                 new_basic[i-1][j-1] = 1
#             else:
#                 new_basic[i-1][j-1] = 0

# # for i in range(n):
# #     new_basic[x_loc[i]-1][y_loc[i]-1] = basic[x_loc[i]-1][y_loc[i]-1]
    
# for i in range(19):
#     print(' '.join(map(str, basic[i])))    


# ================
# basic = []
# for i in range(19):
#     line = map(int, input().split())
#     basic.append(list(line))


# basic = [
#          [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0],
#          [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], 
#          [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], 
#          [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], 
#          [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], 
#          [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], 
#          [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], 
#          [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], 
#          [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], 
#          [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
#          [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], 
#          [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 
#          [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], 
#          [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], 
#          [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], 
#          [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], 
#          [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], 
#          [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], 
#          [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0],
#          ]
# new_basic = basic
# print(new_basic)
# 십자 뒤집기 결과를 출력한다.
#     1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9
# 01# 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0
# 02# 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0
# 03# 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0
# 04# 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0
# 05# 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0
# 06# 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0
# 07# 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0
# 08# 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0
# 09# 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0
# 10# 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
# 11# 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0
# 12# 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
# 13# 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0
# 14# 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0
# 15# 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0
# 16# 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0
# 17# 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0
# 18# 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0
# 19# 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0
# 2
# 10 10
# 12 12

# 출력 예시
# 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
# 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
# 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
# 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
# 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
# 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
# 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
# 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
# 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
# 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0
# 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
# 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0
# 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
# 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
# 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
# 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
# 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
# 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
# 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0

# n = 2
# x_loc = [10, 12]
# y_loc = [10, 12]
# n = int(input())
# x_loc = []
# y_loc = []
# for i in range(n):
#     x, y = map(int, input().split())
#     x_loc.append(x)
#     y_loc.append(y)

# # 입력된 바둑판의 돌을 반대로 전환
# for i in range(1,20):
#     for j in range(1,20):
#         if i in x_loc:
#             if new_basic[i-1][j-1] == 0:
#                 new_basic[i-1][j-1] = 1
#             else:
#                 new_basic[i-1][j-1] = 0
#         if j in y_loc:
#             if new_basic[i-1][j-1] == 0:
#                 new_basic[i-1][j-1] = 1
#             else:
#                 new_basic[i-1][j-1] = 0

# # 기존 좌표의 기존 값 가져오기
# for i in range(n):
#     # print('n = ', n, 'i = ', i)
#     # print('x_loc[i] =', x_loc[i])
#     # print('y_loc[i] =', y_loc[i])
#     # print('new_basic[x_loc[i] = ', new_basic[x_loc[i]][19-1])
#     # print(new_basic[x_loc[i]-1][y_loc[i]-1], "=", basic[x_loc[i]-1][y_loc[i]-1])
#     new_basic[x_loc[i]-1][y_loc[i]-1] = basic[x_loc[i]-1][y_loc[i]-1]
    
# for i in range(19):
#     print(' '.join(map(str, basic[i])))    



# 기숙사 생활을 하는 학교에서 어떤 금요일(전원 귀가일)에는 모두 집으로 귀가를 한다.

# 오랜만에 집에 간 영일이는 아버지와 함께 두던 매우 큰 오목에 대해서 생각해 보다가
# "바둑판에 돌을 올린 것을 프로그래밍 할 수 있을까?"하고 생각하였다.

# 바둑판(19 * 19)에 n개의 흰 돌을 놓는다고 할 때,
# n개의 흰 돌이 놓인 위치를 출력하는 프로그램을 작성해보자.

# 참고
# 리스트가 들어있는 리스트를 만들면?
# 가로번호, 세로번호를 사용해 2차원 형태의 데이터처럼 쉽게 기록하고 사용할 수 있다.
# 리스트이름[번호][번호] 형식으로 저장되어있는 값을 읽고 쓸 수 있고, 더 확장한 n차원의 리스트도 만들 수 있다.

# 바둑판에 올려 놓을 흰 돌의 개수(n)가 첫 줄에 입력된다.
# 둘째 줄 부터 n+1 번째 줄까지 힌 돌을 놓을 좌표(x, y)가 n줄 입력된다.
# n은 10이하의 자연수이고 x, y 좌표는 1 ~ 19 까지이며, 똑같은 좌표는 입력되지 않는다.

# 출력
# 흰 돌이 올려진 바둑판의 상황을 출력한다.
# 흰 돌이 있는 위치는 1, 없는 곳은 0으로 출력한다.

# 입력 예시   
# 5
# 1 1
# 2 2
# 3 3
# 4 4
# 5 5

# n = int(input())
# n = 5
# basic = [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],]
# x_loc = [1, 2, 3, 4, 5]
# y_loc = [1, 2, 3, 4, 5]
# x_loc = []
# y_loc = []
# for i in range(n):
#     x, y = map(int, input().split())
#     x_loc.append(x)
#     y_loc.append(y)


# for i in range(n+1):
#     try : basic[x_loc[i]-1][y_loc[i]-1] = 1
#     except IndexError:
#         break

# for i in range(19):
#     print(' '.join(map(str, basic[i])))

# 출력 예시
# 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
# 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
# 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
# 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
# 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0
# 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
# 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
# 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
# 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
# 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
# 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
# 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
# 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
# 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
# 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
# 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
# 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
# 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
# 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0






# 6094 : [기초-리스트] 이상한 출석 번호 부르기3(py)
# 정보 선생님은 오늘도 이상한 출석을 부른다.

# 영일이는 오늘도 다른 생각을 해보았다.
# 출석 번호를 다 부르지는 않은 것 같은데... 가장 빠른 번호가 뭐였지?

# 출석 번호를 n번 무작위로 불렀을 때, 가장 빠른 번호를 출력해 보자.

# 단, 
# 첫 번째 번호와 마지막 번호가 몇 번인지는 아무도 모른다.
# 음수(-) 번호, 0번 번호도 있을 수 있다.

# 참고
# 리스트에 출석 번호를 기록해 두었다가, 그 중에서 가장 작은 값을 찾아내면 된다.
# 그런데, 가장 작은 값은 어떻게 어떤 것과 비교하고, 어떻게 찾아야 할까?

# 입력
# 번호를 부른 횟수(n, 1 ~ 10000)가 첫 줄에 입력된다.
# n개의 랜덤 번호(k)가 두 번째 줄에 공백을 사이에 두고 순서대로 입력된다.

# 출력
# 출석을 부른 번호 중에 가장 빠른 번호를 출력한다.

# n = 10
# k = ['10', '4', '2', '3', '6', '6', '7', '9', '8', '5']
# n = int(input())
# k = input().split()
# k = list(map(int, k))
# k.sort()
# print(k[0])


    


# 입력 예시   
# 10
# 10 4 2 3 6 6 7 9 8 5

# 출력 예시
# 2


# 6093 : [기초-리스트] 이상한 출석 번호 부르기2(py)

# 정보 선생님은 수업을 시작하기 전에 이상한 출석을 부른다.

# 학생들의 얼굴과 이름을 빨리 익히기 위해 번호를 무작위(랜덤)으로 부르는데,
# 영일이는 선생님이 부른 번호들을 기억하고 있다가 거꾸로 불러보는 것을 해보고 싶어졌다.

# 출석 번호를 n번 무작위로 불렀을 때, 부른 번호를 거꾸로 출력해 보자.


# 참고
# 번호를 부른 순서를 리스트에 순서대로 기록해 두었다가, 기록한 값들을 거꾸로 출력하면 된다.
# range(시작, 끝, 증감) #시작 수는 포함, 끝 수는 포함하지 않음. [시작, 끝)
# range(n-1, -1, -1) #n-1, n, ..., 3, 2, 1, 0

# 입력
# 번호를 부른 횟수(n, 1 ~ 10000)가 첫 줄에 입력된다.
# n개의 랜덤 번호(k, 1 ~ 23)가 두 번째 줄에 공백을 사이에 두고 순서대로 입력된다.

# 출력
# 출석을 부른 번호 순서를 바꾸어 공백을 두고 출력한다.

# 입력 예시   
# 10
# 10 4 2 3 6 6 7 9 8 5

# 출력 예시
# 5 8 9 7 6 6 3 2 4 10

# n = 10
# k = ['10', '4', '2', '3', '6', '6', '7', '9', '8', '5']
# n = int(input())
# k = input().split()
# print(' '.join(k[::-1]))





# 6092 : [기초-리스트] 이상한 출석 번호 부르기1(설명)(py)
# 정보 선생님은 수업을 시작하기 전에 이상한 출석을 부른다.

# 선생님은 출석부를 보고 번호를 부르는데,
# 학생들의 얼굴과 이름을 빨리 익히기 위해 번호를 무작위(랜덤)으로 부른다.

# 그리고 얼굴과 이름이 잘 기억되지 않는 학생들은 번호를 여러 번 불러
# 이름과 얼굴을 빨리 익히려고 하는 것이다.

# 출석 번호를 n번 무작위로 불렀을 때, 각 번호(1 ~ 23)가 불린 횟수를 각각 출력해보자.


# 입력
# 첫 번째 줄에 출석 번호를 부른 횟수인 정수 n이 입력된다. (1 ~ 10000)
# 두 번째 줄에는 무작위로 부른 n개의 번호(1 ~ 23)가 공백을 두고 순서대로 입력된다.

# 출력
# 1번부터 번호가 불린 횟수를 순서대로 공백으로 구분하여 한 줄로 출력한다.

# 입력 예시   
# 10
# 1 3 2 2 5 6 7 4 5 9

# 출력 예시
# 1 2 1 1 2 1 1 0 1 00 00 00 00 00 00 00 00 00 00 00 00 00 00
# 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
#1000개 리스트
#  b = [11, 18, 3, 19, 1, 9, 20, 23, 18, 7, 19, 6, 9, 2, 14, 10, 22, 20, 10, 6, 6, 5, 6, 1, 20, 17, 22, 14, 21, 13, 17, 16, 2, 14, 17, 14, 11, 17, 10, 19, 3, 2, 8, 13, 13, 14, 1, 15, 1, 10, 17, 10, 21, 1, 12, 2, 6, 5, 7, 21, 2, 7, 6, 13, 4, 3, 16, 3, 14, 16, 22, 5, 9, 14, 11, 1, 11, 5, 16, 19, 8, 6, 20, 20, 14, 6, 7, 7, 23, 16, 19, 12, 21, 12, 8, 10, 8, 11, 21, 18, 10, 18, 20, 18, 15, 5, 10, 5, 4, 4, 2, 5, 21, 10, 14, 18, 4, 2, 13, 20, 18, 13, 20, 6, 18, 18, 7, 4, 9, 5, 16, 1, 11, 18, 3, 11, 13, 18, 15, 23, 12, 15, 11, 21, 9, 19, 21, 4, 19, 11, 17, 16, 9, 8, 2, 14, 21, 16, 14, 22, 15, 12, 1, 23, 15, 18, 18, 23, 4, 15, 8, 13, 10, 6, 22, 19, 23, 20, 13, 17, 17, 13, 22, 22, 14, 5, 7, 16, 9, 19, 19, 23, 2, 17, 4, 9, 8, 6, 9, 5, 15, 23, 13, 16, 11, 10, 16, 1, 8, 1, 2, 19, 16, 3, 10, 23, 6, 4, 16, 7, 2, 17, 8, 14, 15, 9, 1, 14, 16, 14, 8, 5, 17, 16, 21, 15, 16, 14, 22, 16, 3, 9, 8, 19, 3, 11, 6, 2, 3, 20, 18, 17, 20, 2, 12, 4, 16, 5, 10, 9, 8, 6, 13, 13, 14, 7, 8, 22, 10, 1, 17, 21, 12, 12, 7, 10, 19, 19, 4, 7, 3, 13, 8, 18, 10, 9, 21, 18, 11, 14, 17, 2, 17, 21, 6, 10, 10, 15, 9, 9, 12, 2, 17, 1, 19, 22, 19, 16, 20, 17, 20, 5, 10, 5, 4, 5, 11, 11, 18, 17, 3, 22, 10, 4, 5, 6, 21, 14, 7, 1, 1, 16, 13, 6, 5, 13, 18, 8, 8, 6, 17, 11, 12, 15, 7, 21, 14, 14, 16, 5, 8, 23, 8, 8, 6, 23, 10, 9, 22, 2, 20, 6, 1, 13, 6, 20, 13, 5, 11, 14, 5, 9, 6, 22, 18, 20, 21, 9, 6, 22, 21, 8, 13, 15, 3, 16, 8, 23, 22, 9, 3, 17, 18, 17, 12, 8, 18, 14, 22, 12, 17, 16, 8, 15, 20, 1, 6, 19, 8, 21, 20, 19, 13, 1, 18, 11, 5, 10, 16, 22, 18, 13, 18, 13, 1, 7, 3, 9, 13, 8, 14, 12, 11, 17, 22, 8, 16, 6, 7, 6, 12, 2, 16, 14, 8, 20, 7, 23, 21, 8, 10, 1, 5, 9, 14, 8, 15, 22, 19, 6, 11, 15, 20, 17, 8, 21, 18, 2, 11, 16, 3, 19, 7, 8, 17, 1, 11, 10, 22, 8, 14, 2, 10, 18, 23, 15, 21, 4, 6, 8, 14, 12, 15, 10, 15, 21, 12, 10, 12, 20, 12, 23, 17, 15, 12, 17, 19, 19, 4, 8, 8, 2, 7, 6, 17, 19, 7, 7, 18, 17, 12, 17, 15, 2, 18, 18, 9, 14, 17, 3, 19, 6, 11, 14, 12, 2, 11, 17, 1, 11, 23, 12, 22, 2, 18, 23, 6, 17, 9, 12, 22, 18, 3, 15, 4, 1, 18, 18, 10, 21, 17, 21, 21, 12, 7, 14, 3, 16, 3, 17, 5, 15, 15, 17, 20, 18, 10, 7, 12, 13, 8, 22, 20, 9, 12, 2, 1, 4, 1, 3, 5, 15, 18, 23, 6, 21, 22, 6, 21, 2, 18, 11, 4, 5, 4, 1, 8, 19, 22, 7, 18, 7, 6, 2, 19, 6, 7, 14, 16, 10, 13, 2, 9, 17, 23, 12, 18, 9, 19, 21, 23, 1, 21, 13, 20, 1, 4, 5, 16, 17, 11, 19, 19, 13, 18, 18, 4, 5, 20, 3, 19, 21, 19, 7, 10, 17, 13, 18, 12, 23, 15, 21, 19, 3, 17, 17, 8, 20, 22, 7, 10, 20, 13, 7, 14, 16, 15, 19, 5, 9, 2, 13, 12, 7, 5, 10, 16, 10, 21, 23, 1, 23, 21, 10, 15, 23, 23, 19, 11, 18, 6, 12, 2, 12, 22, 7, 17, 17, 14, 14, 13, 1, 4, 9, 9, 7, 19, 8, 22, 1, 16, 22, 21, 3, 8, 5, 11, 12, 5, 19, 8, 21, 5, 15, 20, 15, 11, 12, 17, 23, 22, 22, 9, 18, 12, 22, 2, 10, 18, 9, 17, 20, 9, 5, 2, 14, 4, 22, 9, 2, 1, 7, 2, 1, 23, 5, 8, 22, 14, 23, 23, 7, 11, 16, 11, 11, 6, 16, 5, 1, 23, 9, 3, 1, 23, 2, 18, 7, 11, 1, 10, 19, 4, 21, 2, 9, 21, 16, 5, 1, 10, 19, 6, 3, 18, 22, 14, 8, 10, 9, 6, 22, 3, 17, 5, 15, 5, 7, 17, 22, 15, 12, 20, 7, 13, 17, 3, 19, 3, 1, 11, 9, 19, 16, 6, 1, 5, 17, 16, 5, 14, 10, 18, 20, 11, 21, 18, 17, 11, 15, 21, 7, 1, 11, 4, 16, 23, 17, 1, 20, 22, 23, 23, 9, 17, 22, 5, 20, 20, 10, 2, 4, 14, 20, 2, 22, 16, 2, 16, 8, 10, 21, 3, 21, 16, 23, 10, 22, 5, 22, 1, 18, 9, 18, 5, 22, 3, 17, 7, 10, 22, 3, 7, 6, 18, 8, 13, 8, 19, 23, 16, 17, 16, 4, 6, 9, 3, 20, 6, 8, 15, 17, 7, 19, 21, 7, 11, 13, 16, 5, 1, 21, 22, 7, 13, 12, 16, 3, 20, 21, 12, 11, 15, 23, 18, 1, 22, 1, 12, 21, 22, 5, 16, 11, 6, 1, 5, 10, 20, 21, 1, 9, 19, 3, 7, 5, 21, 9, 10, 12, 5, 20, 2, 14, 4, 14, 10, 9, 12, 2, 19, 14, 18, 12, 7, 7, 4, 2, 5, 13, 21, 8, 13, 15, 12, 2, 6, 3, 6, 22]
# 다시 풀어야 함


# 제출용


# number = []
# count = []
# for i in range(1,24):
#     number.append((i))
#     count.append(0)  

# n = int(input())
# b = input().split()
# b = list(map(int, b))
# # b = [11, 18, 3, 19, 1, 9, 20, 23, 18, 7, 19, 6, 9, 2, 14, 10, 22, 20, 10, 6, 6, 5, 6, 1, 20, 17, 22, 14, 21, 13, 17, 16, 2, 14, 17, 14, 11, 17, 10, 19, 3, 2, 8, 13, 13, 14, 1, 15, 1, 10, 17, 10, 21, 1, 12, 2, 6, 5, 7, 21, 2, 7, 6, 13, 4, 3, 16, 3, 14, 16, 22, 5, 9, 14, 11, 1, 11, 5, 16, 19, 8, 6, 20, 20, 14, 6, 7, 7, 23, 16, 19, 12, 21, 12, 8, 10, 8, 11, 21, 18, 10, 18, 20, 18, 15, 5, 10, 5, 4, 4, 2, 5, 21, 10, 14, 18, 4, 2, 13, 20, 18, 13, 20, 6, 18, 18, 7, 4, 9, 5, 16, 1, 11, 18, 3, 11, 13, 18, 15, 23, 12, 15, 11, 21, 9, 19, 21, 4, 19, 11, 17, 16, 9, 8, 2, 14, 21, 16, 14, 22, 15, 12, 1, 23, 15, 18, 18, 23, 4, 15, 8, 13, 10, 6, 22, 19, 23, 20, 13, 17, 17, 13, 22, 22, 14, 5, 7, 16, 9, 19, 19, 23, 2, 17, 4, 9, 8, 6, 9, 5, 15, 23, 13, 16, 11, 10, 16, 1, 8, 1, 2, 19, 16, 3, 10, 23, 6, 4, 16, 7, 2, 17, 8, 14, 15, 9, 1, 14, 16, 14, 8, 5, 17, 16, 21, 15, 16, 14, 22, 16, 3, 9, 8, 19, 3, 11, 6, 2, 3, 20, 18, 17, 20, 2, 12, 4, 16, 5, 10, 9, 8, 6, 13, 13, 14, 7, 8, 22, 10, 1, 17, 21, 12, 12, 7, 10, 19, 19, 4, 7, 3, 13, 8, 18, 10, 9, 21, 18, 11, 14, 17, 2, 17, 21, 6, 10, 10, 15, 9, 9, 12, 2, 17, 1, 19, 22, 19, 16, 20, 17, 20, 5, 10, 5, 4, 5, 11, 11, 18, 17, 3, 22, 10, 4, 5, 6, 21, 14, 7, 1, 1, 16, 13, 6, 5, 13, 18, 8, 8, 6, 17, 11, 12, 15, 7, 21, 14, 14, 16, 5, 8, 23, 8, 8, 6, 23, 10, 9, 22, 2, 20, 6, 1, 13, 6, 20, 13, 5, 11, 14, 5, 9, 6, 22, 18, 20, 21, 9, 6, 22, 21, 8, 13, 15, 3, 16, 8, 23, 22, 9, 3, 17, 18, 17, 12, 8, 18, 14, 22, 12, 17, 16, 8, 15, 20, 1, 6, 19, 8, 21, 20, 19, 13, 1, 18, 11, 5, 10, 16, 22, 18, 13, 18, 13, 1, 7, 3, 9, 13, 8, 14, 12, 11, 17, 22, 8, 16, 6, 7, 6, 12, 2, 16, 14, 8, 20, 7, 23, 21, 8, 10, 1, 5, 9, 14, 8, 15, 22, 19, 6, 11, 15, 20, 17, 8, 21, 18, 2, 11, 16, 3, 19, 7, 8, 17, 1, 11, 10, 22, 8, 14, 2, 10, 18, 23, 15, 21, 4, 6, 8, 14, 12, 15, 10, 15, 21, 12, 10, 12, 20, 12, 23, 17, 15, 12, 17, 19, 19, 4, 8, 8, 2, 7, 6, 17, 19, 7, 7, 18, 17, 12, 17, 15, 2, 18, 18, 9, 14, 17, 3, 19, 6, 11, 14, 12, 2, 11, 17, 1, 11, 23, 12, 22, 2, 18, 23, 6, 17, 9, 12, 22, 18, 3, 15, 4, 1, 18, 18, 10, 21, 17, 21, 21, 12, 7, 14, 3, 16, 3, 17, 5, 15, 15, 17, 20, 18, 10, 7, 12, 13, 8, 22, 20, 9, 12, 2, 1, 4, 1, 3, 5, 15, 18, 23, 6, 21, 22, 6, 21, 2, 18, 11, 4, 5, 4, 1, 8, 19, 22, 7, 18, 7, 6, 2, 19, 6, 7, 14, 16, 10, 13, 2, 9, 17, 23, 12, 18, 9, 19, 21, 23, 1, 21, 13, 20, 1, 4, 5, 16, 17, 11, 19, 19, 13, 18, 18, 4, 5, 20, 3, 19, 21, 19, 7, 10, 17, 13, 18, 12, 23, 15, 21, 19, 3, 17, 17, 8, 20, 22, 7, 10, 20, 13, 7, 14, 16, 15, 19, 5, 9, 2, 13, 12, 7, 5, 10, 16, 10, 21, 23, 1, 23, 21, 10, 15, 23, 23, 19, 11, 18, 6, 12, 2, 12, 22, 7, 17, 17, 14, 14, 13, 1, 4, 9, 9, 7, 19, 8, 22, 1, 16, 22, 21, 3, 8, 5, 11, 12, 5, 19, 8, 21, 5, 15, 20, 15, 11, 12, 17, 23, 22, 22, 9, 18, 12, 22, 2, 10, 18, 9, 17, 20, 9, 5, 2, 14, 4, 22, 9, 2, 1, 7, 2, 1, 23, 5, 8, 22, 14, 23, 23, 7, 11, 16, 11, 11, 6, 16, 5, 1, 23, 9, 3, 1, 23, 2, 18, 7, 11, 1, 10, 19, 4, 21, 2, 9, 21, 16, 5, 1, 10, 19, 6, 3, 18, 22, 14, 8, 10, 9, 6, 22, 3, 17, 5, 15, 5, 7, 17, 22, 15, 12, 20, 7, 13, 17, 3, 19, 3, 1, 11, 9, 19, 16, 6, 1, 5, 17, 16, 5, 14, 10, 18, 20, 11, 21, 18, 17, 11, 15, 21, 7, 1, 11, 4, 16, 23, 17, 1, 20, 22, 23, 23, 9, 17, 22, 5, 20, 20, 10, 2, 4, 14, 20, 2, 22, 16, 2, 16, 8, 10, 21, 3, 21, 16, 23, 10, 22, 5, 22, 1, 18, 9, 18, 5, 22, 3, 17, 7, 10, 22, 3, 7, 6, 18, 8, 13, 8, 19, 23, 16, 17, 16, 4, 6, 9, 3, 20, 6, 8, 15, 17, 7, 19, 21, 7, 11, 13, 16, 5, 1, 21, 22, 7, 13, 12, 16, 3, 20, 21, 12, 11, 15, 23, 18, 1, 22, 1, 12, 21, 22, 5, 16, 11, 6, 1, 5, 10, 20, 21, 1, 9, 19, 3, 7, 5, 21, 9, 10, 12, 5, 20, 2, 14, 4, 14, 10, 9, 12, 2, 19, 14, 18, 12, 7, 7, 4, 2, 5, 13, 21, 8, 13, 15, 12, 2, 6, 3, 6, 22]

# for i in b:
#     for j in number:
#         if i == j:
#             count[j-1] = count[j-1] + 1
#         else:
#             count[j-1] = count[j-1] + 0

# count = list(map(str, count))
# print(' '.join(count))



# import random

# number = []
# count = []
# for i in range(1,24):
#     number.append((i))
#     count.append(0)  


# print(number)
# print(count)

# n = int(input())
# # n = 10
# # b = input().split()
# # b = ['1', '3', '2', '2', '5', '6', '7', '4', '5', '9']
# b = []
# for i in range(n):
#     b.append(random.randrange(1,24))
# print(b, type(b))
# # b = list(map(int, b))

# for i in b:
#     for j in number:
#         # print(i, j,)
#         if i == j:
#             # print(count[j-1], type(count[j-1]), "->", int(count[j-1]) + 1)
#             count[j-1] = count[j-1] + 1
#         else:
#             count[j-1] = count[j-1] + 0

# count = list(map(str, count))
# # number = list(map(str, number))
# print(' '.join(count))
# # print(' '.join(number))

    

# 6091 : [기초-종합] 함께 문제 푸는 날
# 온라인 채점시스템에는 초등학생, 중고등학생, 대학생, 대학원생,
# 일반인, 군인, 프로그래머, 탑코더 등 아주 많은 사람들이 들어와 문제를 풀고 있는데,

# 실시간 채점 정보는 메뉴의 채점기록(Judge Status)을 통해 살펴볼 수 있다.

# 자! 여기서...잠깐..
# 같은 날 동시에 가입한 3명의 사람들이 온라인 채점시스템에 들어와 문제를 푸는 날짜가
# 매우 규칙적이라고 할 때, 다시 모두 함께 문제를 풀게 되는 그날은 언제일까?

# 예를 들어 3명이 같은 날 가입/등업하고, 각각 3일마다, 7일마다, 9일마다
# 한 번씩 들어온다면, 처음 가입하고 63일 만에 다시 3명이 함께 문제를 풀게 된다.

# 갑자기 힌트?
# 왠지 어려워 보이지 않는가?
# 수학에서 배운 최소공배수를 생각한 사람들도 있을 것이다. 하지만, 정보에서 배우고 경험하는
# 정보과학의 세상은 때때로 컴퓨터의 힘을 빌려 간단한 방법으로 해결할 수 있게 한다.

# 아래의 코드를 읽고 이해한 후 도전해 보자.
# day는 날 수, a/b/c는 방문 주기이다.
# ...
# d = 1
# while d%a!=0 or d%b!=0 or d%c!=0 :
#   d += 1
# print(d)
# ...

# 물론, 아주 많은 다양한 방법이 있을 수 있다.

# 정보과학의 문제해결에 있어서 정답은?
# 하나가 아니라 주어진 시간/기억공간으로 정확한 결과를 얻을 수 있는 모든 방법이다.

# 따라서, 모든 문제들에는 정답이 하나뿐만이 아니다.
# 새로운, 더 빠른, 더 간단한 방법을 다양하게 생각해보고 여러가지 방법으로 도전해 볼 수 있다.

# 입력
# 같은 날 동시에 가입한 인원 3명이 규칙적으로 방문하는,
# 방문 주기가 공백을 두고 입력된다. (단, 입력값은 100이하의 자연수이다.)

# 출력
# 3명이 다시 모두 함께 방문해 문제를 풀어보는 날(동시 가입/등업 후 며칠 후?)을 출력한다.

# 입력 예시   
# 3 7 9

# 출력 예시
# 63


# a, b, c = map(int, input().split())
# d = 1
# while d%a != 0 or d%b != 0 or  d%c != 0:
#     d += 1
# print(d)




# 어떤 규칙에 따라 수를 순서대로 나열한 것을 수열(sequences)이라고 한다.

# 예를 들어
# 1 -1 3 -5 11 1 43 ... 은
# 1부터 시작해 이전에 만든 수에 를 곱한 다음 1을 더해 다음 수를 만든 수열이다.

# 이런 이상한 수열을 알게 된 영일이는 또 궁금해졌다.
# "그럼.... 13번째 나오는 수는 뭘까?"

# 영일이는 물론 수학을 아주 잘하지만 이런 문제는 본 적이 거의 없었다...
# 그래서 프로그램을 만들어 더 큰 수도 자동으로 계산하고 싶어졌다.

# 시작 값(a), 곱할 값(m), 더할 값(d), 몇 번째인지를 나타내는 정수(n)가 입력될 때,
# n번째 수를 출력하는 프로그램을 만들어보자.




# 입력
# 시작 값(a), 곱할 값(m), 더할 값(d), 몇 번째 인지를 나타내는 정수(n)가
# 공백을 두고 입력된다.(a, m, d는 -50 ~ +50, n은 10이하의 자연수)

# 출력
# n번째 수를 출력한다.

# 입력 예시   
# 1  1 8

# 출력 예시
# -85

# a, m, d, n = map(int, input().split())
# total = a
# print("1번 :", total)
# for i in range(2, n+1):
#   if i < 10:
#     print("0"+ str(i), "번 :", total, "*", m, "=", total * m, "\n      ", total * m, "+", d, "=", total * m + d)
#   else: print(i, "번 :", total, "*", m, "=", total * m, "\n      ", total * m, "+", d, "=", total * m + d)
#   total = total * m + d

# print(total)

# 어떤 규칙에 따라 수를 순서대로 나열한 것을 수열(sequences)이라고 한다.

# 예를 들어
# 2 6 18 54 162 486 ... 은
# 2부터 시작해 이전에 만든 수에 3을 곱해 다음 수를 만든 수열이다.

# 이러한 것을 수학에서는 앞뒤 수들의 비율이 같다고 하여
# 등비(비율이 같다의 한문 말) 수열이라고 한다. (등비수열 : geometric progression/sequence)

# 등비 수열을 알게된 영일이는 갑자기 궁금해졌다.
# "그럼.... 13번째 나오는 수는 뭘까?"
# 영일이는 프로그램을 만들어 더 큰 수도 자동으로 계산하고 싶어졌다.

# 시작 값(a), 등비(r), 몇 번째인지를 나타내는 정수(n)가 입력될 때
# n번째 수를 출력하는 프로그램을 만들어보자.


# 입력
# 시작 값(a), 등비의 값(r), 몇 번째 인지를 나타내는 정수(n)가
# 공백을 두고 입력된다.(모두 0 ~ 10)

# 출력
# n번째 수를 출력한다.

# 입력 예시   
# 2 3 7

# 출력 예시
# 1458


# a, r, n = map(int, input().split())
# total = a
# print("1 번 :", total)
# for i in range(2, n+1):
#   print(i, "번 :", total * r)
#   total *= r
# print(total)



# 어떤 규칙에 따라 수를 순서대로 나열한 것을 수열(sequences)이라고 한다.

# 예를 들어
# 1 4 7 10 13 16 19 22 25 ... 은
# 1부터 시작해 이전에 만든 수에 3을 더해 다음 수를 만든 수열이다.
# 이러한 것을 수학에서는 앞뒤 수들의 차이가 같다고 하여

# 등차(차이가 같다의 한문 말) 수열이라고 한다. (등차수열 : arithmetic progression/sequence)
# 수열을 알게 된 영일이는 갑자기 궁금해졌다.

# "그럼.... 123번째 나오는 수는 뭘까?"

# 영일이는 프로그램을 만들어 더 큰 수도 자동으로 계산하고 싶어졌다.

# 시작 값(a), 등차(d), 몇 번째인지를 나타내는 정수(n)가 입력될 때
# n번째 수를 출력하는 프로그램을 만들어보자.




# 입력
# 시작 값(a), 등차의 값(d), 몇 번째 수 인지를 의미하는 정수(n)가
# 공백을 두고 입력된다.(모두 0 ~ 100)

# 출력
# n번째 수를 출력한다.

# 입력 예시   
# 1 3 5

# 출력 예시
# 13


# a, d, n = map(int, input().split())
# sum = a
# for i in range(2, n+1):
#   sum += d
# print(sum)

# 1, 2, 3 ... 을 순서대로 계속 더해 합을 만드는데, 그 합이 입력한 정수보다 작을 동안만 계속 더하는 프로그램을 작성해보자.
# 즉, 1부터 n까지 정수를 하나씩 더해 합을 만드는데, 어디까지 더해야 입력한 수보다 같거나 커지는지 알아보고자 하는 문제이다.
# 하지만, 이번에는 그 때 까지의 합을 출력해야 한다.

# 예를 들어, 57을 입력하면 1+2+3+...+8+9+10=55에서 그 다음 수인 11을 더해 66이 될 때,  그 값 66이 출력되어야 한다.

# 입력
# 언제까지 합을 계산할 지, 정수 1개를 입력받는다.
# 단, 입력되는 자연수는 100,000,000이하이다.

# 출력
# 1, 2, 3, 4, 5 ... 순서대로 계속 더해가다가, 그 합이 입력된 정수보다 커지거나 같아지는 경우,
# 그때까지의 합을 출력한다.

# 입력 예시   
# 57

# 출력 예시
# 66

# num = int(input())
# sum = 0
# for i in range(100000000):
#   if sum < num:
#     sum += i
#   else:
#     break
# print(sum)






# 이미지가 컴퓨터에 저장될 때에도 디지털 데이터화 되어 저장된다.

# 가장 기본적인 방법으로는 그림을 구성하는 한 점(pixel, 픽셀)의 색상을
# 빨강(r), 초록(g), 파랑(b)의 3가지의 빛의 세기 값으로 따로 변환하여 저장하는 것인데,

# 예를 들어 r, g, b 각 색에 대해서 8비트(0~255, 256가지 가능)씩을 사용한다고 하면,

# 한 점의 색상은 3가지 r, g, b의 8비트+8비트+8비트로 총 24비트로 표현해서
# 총 2^24 가지의 서로 다른 빛의 색깔을 사용할 수 있는 것이다.

# 그렇게 저장하는 점을 모아 하나의 큰 이미지를 저장할 수 있게 되는데,
# 1024 * 768 사이즈에 각 점에 대해 24비트로 저장하면 그 이미지를 저장하기 위한
# 저장 용량을 계산할 수 있다.

# 이렇게 이미지의 원래(raw) 데이터를 압축하지 않고 그대로 저장하는 대표적인 이미지 파일이
# *.bmp 파일이며, 비트로 그림을 구성한다고 하여 비트맵 방식 또는 래스터 방식이라고 한다.

# 이미지의 가로 해상도 w, 세로 해상도 h, 한 픽셀을 저장하기 위한 비트 b 가 주어질 때,
# 압축하지 않고 저장하기 위해 필요한 저장 용량을 계산하는 프로그램을 작성해 보자.

# 예를 들어
# 일반적인 1024 * 768 사이즈(해상도)의 각점에 대해
# 24비트(rgb 각각 8비트씩 3개)로 저장하려면
# 1024 * 768 * 24 bit의 저장공간이 필요한데,
# 1024*768*24/8/1024/1024 로 계산하면 약 2.25 MB 정도가 필요하다.

# 실제 그런지 확인하고 싶다면, 간단한 그림 편집/수정 프로그램을 통해 확인할 수 있다.

# **
#       8 bit(비트)           = 1byte(바이트)     #       8bit=1Byte
# 1024 Byte(210 byte) = 1KB(킬로 바이트)  # 1024Byte=1KB
# 1024 KB(210 KB)      = 1MB(메가 바이트)
# 1024 MB(210 MB)     = 1GB(기가 바이트)
# 1024 GB(210 GB)      = 1TB(테라 바이트)

# w, h, b 가 공백을 두고 입력된다.
# 단, w, h는 모두 정수이고 1~1024 이다. b는 40이하의 4의 배수이다.

# 필요한 저장 공간을 MB 단위로 바꾸어 출력한다.
# 단, 소수점 셋째 자리에서 반올림하여 둘째 자리까지 출력한다.

# 입력 예시   
# 1024 768 24

# 출력 예시
# 2.25 MB


#Python 소수점 이하 자리수 포함 출력 바업
# n=float(input())

# print('%.6f' % n)

# w, h, b = input().split()
# storage = float(round(int(w) * int(h) * int(b) / 8 / 1024 / 1024, 210))
# print('%.2f' %storage, "MB")


# 소리가 컴퓨터에 저장될 때에는 디지털 데이터화 되어 저장된다.

# 마이크를 통해 1초에 적게는 수십 번, 많게는 수만 번 소리의 강약을 체크하고, # 한 번씩 체크할 때 마다 그 값을 정수값으로 바꾸어 저장하는 방식으로 소리를 파일로 저장할 수 있다.

# 값을 저장할 때에는 비트를 사용하는 정도에 따라 세세한 녹음 정도를 결정할 수 있고, # 좌우(스테레오) 채널로 저장하면 2배… 5.1채널이면 6배의 저장공간이 필요하고,
# 녹음 시간이 길면 그 만큼 더 많은 저장공간이 필요하다.

# 1초 동안 마이크로 소리강약을 체크하는 횟수를 h (헤르쯔, Hz 는 1초에 몇 번? 체크하는가를 의미한다.)

# 한 번 체크한 값을 저장할 때 사용하는 비트수를 b (2비트를 사용하면 0 또는 1 두 가지, 16비트를 사용하면 65536가지..)

# 좌우 등 소리를 저장할 트랙 개수인 채널 개수를 c (모노는 1개, 스테레오는 2개의 트랙으로 저장함을 의미한다.)

# 녹음할 시간(초) s가 주어질 때, 필요한 저장 용량을 계산하는 프로그램을 작성해보자.

# 실제로, 일반적인 CD 음질(44.1KHz, 16bit, 스테레오)로 1초 동안 저장하려면
# 44100 * 16 * 2 * 1 bit의 저장공간이 필요한데,
# 44100*16*2*1/8/1024/1024 로 계산하면 약 0.168 MB 정도가 필요하다.

# 이렇게 녹음하는 방식을 PCM(Pulse Code Modulation) 방법이라고 하는데,
# 압축하지 않은 순수한(raw) 소리 데이터 파일은 대표적으로 *.wav 가 있다.

# 입력
# h, b, c, s 가 공백을 두고 입력된다.
# h는 48,000이하, b는 32이하(단, 8의배수), c는 5이하, s는 6,000이하의 자연수이다.

# 출력
# 필요한 저장 공간을 MB 단위로 바꾸어 출력한다.
# 단, 소수점 첫째 자리까지의 정확도로 출력하고 MB를 공백을 두고 출력한다.


# **
#    8 bit(비트)      = 1byte(바이트)       # 8bit=1Byte
# 1024 Byte(210 byte) = 1KB(킬로 바이트)    # 1024Byte=1KB
# 1024 KB(210 KB)     = 1MB(메가 바이트)
# 1024 MB(210 MB)     = 1GB(기가 바이트)
# 1024 GB(210 GB)     = 1TB(테라 바이트)

# h, b, c, s = input().split()
# storage = round(int(h) * int(b) * int(c) * int(s) / 8 / 1024 / 1024, 1)
# print(storage, "MB")

# 입력 예시   
# 44100 16 2 10

# 출력 예시
# 1.7 MB




# # 빨강(red), 초록(green), 파랑(blue) 빛을 섞어 여러 가지 다른 색 빛을 만들어 내려고 한다.

# # 빨강(r), 초록(g), 파랑(b) 각 빛의 가짓수가 주어질 때,
# # 주어진 rgb 빛들을 섞어 만들 수 있는 모든 경우의 조합(r g b)과 만들 수 있는 색의 가짓 수를 계산해보자.  

# # **모니터, 스마트폰과 같은 디스플레이에서 각 픽셀의 색을 만들어내기 위해서 r, g, b 색을 조합할 수 있다.
# # **픽셀(pixel)은 그림(picture)을 구성하는 셀(cell)에서 이름이 만들어졌다.

# 입력
# 빨녹파(r, g, b) 각 빛의 가짓수가 공백을 두고 입력된다.
# 예를 들어, 3 3 3 은 빨녹파 빛에 대해서 각각 0~2까지 3가지 색이 있음을 의미한다.
# 0 <= r,g,b <= 127
 

#  출력
# 만들 수 있는 rgb 색의 정보를 오름차순(계단을 올라가는 순, 12345... abcde..., 가나다라마...)으로
# 줄을 바꿔 모두 출력하고, 마지막에 그 개수를 출력한다.


# 입력 예시   
# 2 2 2

# 출력 예시
# 0 0 0
# 0 0 1
# 0 1 0
# 0 1 1
# 1 0 0
# 1 0 1
# 1 1 0
# 1 1 1
# 8

# r, g, b = input().split()
# r = int(r)
# g = int(g)
# b = int(b)
# i = 0
# for c1 in range(r):
#   for c2 in range(g):
#     for c3 in range(b):
#       print(c1, c2, c3)
#       i += 1
# print(i)








# 친구들과 함께 3 6 9 게임을 하던 영일이는 잦은 실수 때문에 계속해서 벌칙을 받게 되었다.
# 3 6 9 게임의 왕이 되기 위한 369 마스터 프로그램을 작성해 보자.

# ** 3 6 9 게임은?
# 여러 사람이 순서를 정한 후, 순서대로 수를 부르는 게임이다.
# 만약 3, 6, 9 가 들어간 수를 자신이 불러야 하는 상황이라면, 수를 부르는 대신 "박수(X)" 를 쳐야 한다.
# 33과 같이 3,6,9가 두 번 들어간 수 일때, "짝짝"과 같이 박수를 두 번 치는 형태도 있다. 

# 30 보다 작은 정수 1개가 입력된다.
# (1 ~ 29)

# 1 부터 그 수까지 순서대로 공백을 두고 수를 출력하는데,
# 3 또는 6 또는 9가 포함 되어있는 수인 경우, 그 수 대신 영문 대문자 X 를 출력한다.

# 입력 예시 
# 9

# 출력 예시
# 1 2 X 4 5 X 7 8 X


# num = int(input())
# for i in range(1, num+1):
#   if i < 10 and i % 3 == 0:
#     print("X", end = " ")
#   elif i % 10 > 0 and (i%10) % 3 == 0:
#     print("X", end = " ")
#   else:
#     print(i, end = " ")




# 1부터 n까지, 1부터 m까지 숫자가 적힌 서로 다른 주사위 2개를 던졌을 때,
# 나올 수 있는 모든 경우를 출력해보자.

# 서로 다른 주사위 2개의 면의 개수 n, m이 공백을 두고 입력된다.
# 단, n, m은 10이하의 자연수

# 입력 예시
# 2 3

# 출력 예시
# 1 1
# 1 2
# 1 3
# 2 1
# 2 2
# 2 3

# n, m = input().split()
# n = int(n)
# m = int(m)
# for n in range(1, n+1):
#   for m in range(1, m+1):
#     print(n, m)


# 1, 2, 3 ... 을 계속 더해 나갈 때,
# 그 합이 입력한 정수(0 ~ 1000)보다 같거나 작을 때까지만
# 계속 더하는 프로그램을 작성해보자.

# 즉, 1부터 n까지 정수를 계속 더해 나간다고 할 때,
# 어디까지 더해야 입력한 수보다 같거나 커지는 지를 알아보고자하는 문제이다.

# 정수 1개가 입력된다.
# 1, 2, 3, 4, 5 ... 를 순서대로 계속 더해 합을 만들어가다가,
# 입력된 정수와 같거나 커졌을 때, 마지막에 더한 정수를 출력한다.



# num = int(input())
# sum = 0
# for i in range(1, num+1):
#   sum += i
#   if sum >= num:
#     print(i)
#     break





# 영문 소문자 'q'가 입력될 때까지
# 입력한 문자를 계속 출력하는 프로그램을 작성해보자.

# while True:
#   str = input()
#   if str == 'q':
#     print(str)
#     break
#   else:
#     print(str)




# 정수(1 ~ 100) 1개를 입력받아 1부터 그 수까지 짝수의 합을 구해보자.

# 예시
#다음 코드는 홀 수만 더해 출력한다.
# n = int(input())
# s = 0
# for i in range(1, n+1) :
#   if i%2==1 :
#     s += i

# print(s)

# num = int(input())
# sum = 0
# for i in range(1, num+1):
#   if i % 2 == 0:
#     sum += i
# print(sum)

# while True:
#   try :
#     num = int(input('정수를 입력하세요 : '))
#     sum = 0
#     for i in range(1, num+1):
#       if i % 2 == 0:
#         sum += i
#     break
#   except ValueError:
#     print("정수가 아닙니다.")
# print(sum)



# # 3의 배수는 통과
# # 정수 1개를 입력받는다.
# # (1 ~ 100)
# # 1부터 입력한 정수보다 작거나 같을 때까지 1씩 증가시켜 출력하되
# # 3의 배수는 출력하지 않는다.

# # 입력예시: 10
# # 출력 예시: 1 2 4 5 7 8 10

# num = float(input("숫자를 입력하세요 : "))
# i = 1
# while i <= num:
#   if i%3 == 0:
#     i+=1
#   else:
#     print(i)
#     i+=1

# print("===========================")

# for i in range(1, int(num)+1):
#   if i % 3 == 0:
#     continue
#   print(i)
